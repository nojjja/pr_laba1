Цель лабораторной работы — изучить технологию контейнеризации и работу Docker, а также научиться:

Создавать простое веб-приложение на Python (Flask)

Запускать приложение в Docker-контейнере

Проверять работу приложения через HTTP-запросы (curl)


Теоретическая часть
Контейнеризация

Контейнеризация позволяет изолировать приложения и их зависимости в отдельной среде.

Контейнеры легче и быстрее виртуальных машин, так как используют ядро хост-системы.

Преимущества: портативность, консистентность окружения, лёгкость масштабирования.

Docker

Образ (image) — шаблон для запуска контейнера, включает приложение и все зависимости.

Контейнер (container) — запущенный экземпляр образа.

Dockerfile — текстовый файл с инструкциями для сборки образа.

Основные команды Docker:

docker build -t <имя_образа> . — сборка образа из Dockerfile

docker run -d -p <порт_хоста>:<порт_контейнера> <имя_образа> — запуск контейнера

docker ps — просмотр запущенных контейнеров

docker logs <container_id> — просмотр логов контейнера


Файл Dockerfile:

# Используем официальный образ Python
FROM python:3.10-slim


# Устанавливаем рабочую директорию
WORKDIR /app


# Копируем все файлы приложения
COPY . /app


# Устанавливаем зависимости
RUN pip install --no-cache-dir flask


# Открываем порт для доступа извне
EXPOSE 5555


# Команда для запуска приложения
CMD ["python", "runserver.py"]


Сборка образа и запуск контейнера
# Сборка образа
docker build -t factorial-app .


# Запуск контейнера с пробросом порта
docker run -d -p 5555:5555 factorial-app

-d — запуск в фоне

-p 5555:5555 — проброс порта на хост


Проверка работы приложения
Через браузер:

Открыть http://localhost:5555

Должна появиться форма для ввода числа и кнопка "Вычислить"

Через curl:
# GET-запрос к главной странице
curl "http://localhost:5555/"


# POST-запрос для вычисления факториала
curl -X POST "http://localhost:5555/factorial" -d "n=5"
# Ответ: 5! = 120


Проблемы, с которыми столкнулась, и их решения

Flask не был доступен из контейнера

Решение: в runserver.py указала HOST = '0.0.0.0', чтобы слушать все интерфейсы.

Ошибка кодировки Python (Non-UTF-8 code)

Решение: файл runserver.py сохранила в UTF-8 и добавила # -*- coding: utf-8 -*- при необходимости.

Порт 5555 был занят локально

Решение: закрыла процессы, которые использовали порт, через taskkill /PID <pid>.

Ошибка подключения к Docker API

Решение: полностью перезапустила Docker Desktop, убедилась, что выбран контекст desktop-linux.


Выводы

Лабораторная работа показала, как разрабатывать простое веб-приложение и запускать его в Docker.

Контейнеризация упрощает переносимость приложения и изоляцию окружения.

Проверка через браузер и curl подтвердила, что приложение работает корректно.

Получила практический опыт работы с Dockerfile, сборкой образа, пробросом портов и управлением контейнерами.